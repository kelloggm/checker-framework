\htmlhr
\chapterAndLabel{Resource Leak Checker for must-call obligations}{resource-leak-checker}

The Resource Leak Checker guarantees that every object in the program
has its must-call obligations fulfilled before it is de-allocated.
Typically, this checker is used to detect and prevent resource leaks,
which occur when the programmer does not explicitly dispose of some finite resource,
such as a socket, file descriptor, or database connection. However, this checker
is general enough to enforce any property of the form "the programmer must call
all methods in the set of methods \emph{M} on object \emph{O} before \emph{O}
is de-allocated" for any set of methods \emph{M} and object \emph{O}.
For resource leaks, by default \emph{M} is the set containing \<close()> and \emph{O}
is any object that implements the interface \<java.io.Closeable>.

The Resource Leak Checker works in three stages:
\begin{enumerate}
\item The Must Call Checker (Section~\ref{must-call-checker})
over-approximates a set of must-call methods \emph{MC} for each expression
in the program by computing a type of the form \<@MustCall(>\emph{MC}\<)>.
This type represents an over-approximation of that expression's must-call obligations.
\item The Called Methods Checker (Section~\ref{called-methods-checker})
under-approximates a set of definitely-called methods \emph{CM} for each expression
in the program by computing a type of the form \<@CalledMethods(>\emph{CM}\<)>.
This type represents a set of methods that were definitely called on that expression;
that is, an under-approximation of the true set of methods that have already been called.
\item When any program element goes out of scope (i.e. is de-allocated), the Resource
Leak Checker compares the sets \emph{MC} and \emph{CM} at the point of de-allocation.
If there exists some method in \emph{MC} that is not in \emph{CM}, an error is reported.
\end{enumerate}

By default, the Resource Leak Checker enforces that the \<close()> method is always
called on any object whose dynamic type might implement \<java.io.Closeable>, via an annotated
JDK. You can extend this guarantee to other types and methods by writing
\<@MustCall> or \<@InheritableMustCall> annotations, as described in
Section~\ref{must-call-annotations}.

\sectionAndLabel{How to run the Resource Leak Checker}{resource-leak-run-checker}

\begin{Verbatim}
javac -processor ResourceLeak MyFile.java ...
\end{Verbatim}

The Resource Leak Checker supports the following optional command-line arguments,
in addition to those listed by Section~\ref{called-methods-run-checker} for
the Called Methods Checker:
\begin{itemize}
\item The \<-AnoLightweightOwnership> option disables ownership annotations,
 ignoring them in favor of the default ownership assumptions.
 See Section~\ref{resource-leak-ownership}.
\item The \<-AnoResourceAliasing> option disables resource alias support,
 treating \<@MustCallAlias> identically to \<@PolyMustCall>.
 See Section~\ref{resource-leak-resource-alias}.
\item The \<-AnoCreatesObligation> option disables obligation creation,
 issuing errors whenever a new obligation might be created instead.
 See Section~\ref{resource-leak-creates-obligation}.
\item The \<-AcountMustCall> option prints an estimate of the number of
must-call obligations in the analyzed program after typechecking is complete.
\end{itemize}

\sectionAndLabel{Resource Leak Checker annotations}{resource-leak-annotations}

The Resource Leak Checker relies on the type qualifiers of its constituent checkers:
the Must Call Checker (Section~\ref{must-call-annotations}) and
the Called Methods Checker (Section~\ref{called-methods-spec}). You might need
to write qualifiers from either type hierarchy. The most common annotations from
these checkers that you might need to write are:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{MustCall}{String[] value}]
for example on an element with static type \<Object> that might contain a \<Socket>.

\item[\refqualclasswithparams{checker/mustcall/qual}{InheritableMustCall}{String[] value}]
on any classes defined in your program that have must-call obligations. See Section~\ref{must-call-on-class}.

\item[\refqualclass{checker/calledmethods/qual}{EnsuresCalledMethods}] on a method in
your code that fulfills a must-call obligation of one of its parameters or of a field.
See Section~\ref{resource-leak-annotating-helpers}.

\end{description}

In addition, the Resource Leak Checker supports annotations that express common
aliasing patterns related to resource leaks:

\begin{description}

\item[\refqualclass{checker/mustcall/qual}{Owning}]
  indicates that the annotated element "owns" any resource associated with
  it. That is, when the annotated element is de-allocated, its must-call
  obligations will be checked. Assignment into an owning element fulfills
  the must-call obligations of the right-hand side of the assignment; for
  details on ownership transfer, see Section~\ref{resource-leak-ownership}.
  By default, local variables and return types are considered \<@Owning>.
  Note that \<@Owning> is a declaration annotation, not a type annotation.

\item[\refqualclass{checker/mustcall/qual}{NotOwning}]
  indicates that the annotated element "borrows" any resource associated with
  it. That is, when the annotated element is de-allocated, its must-call
  obligations will NOT be checked: there exists some other element which is
  \<@Owning> that will be checked instead. For
  details on ownership transfer, see Section~\ref{resource-leak-ownership}.
  By default, fields and method parameters are considered \<@NotOwning>.
  Note that \<@NotOwning> is a declaration annotation, not a type annotation.

\item[\refqualclass{checker/mustcall/qual}{MustCallAlias}]
  is a special polymorphic annotation that represents a "resource-aliasing"
  relationship between two elements. Resource aliases are distinct program elements
  that nevertheless control the same resource(s): fulfilling the must-call obligations
  of one element is equivalent to fulfills the obligations of the other.
  For a more detailed description, see
  Section~\ref{resource-leak-resource-alias}.

\item[\refqualclasswithparams{checker/mustcall/qual}{CreatesObligation}{String value}]
  is a declaration annotation that indicates that the annotated method "resets" the must-call
  obligations of the target (i.e. the \<value> element of the annotation), which must
  be an in-scope Java expression. The default target is \<"this">. Multiple \<@CreatesObligation>
  annotations can be written on the same method, if their targets are distinct. For more details
  on obligation creation, see Section~\ref{resource-leak-creates-obligation}.

\end{description}

\sectionAndLabel{Annotating helper methods}{resource-leak-annotating-helpers}

Consider the following method:
\begin{verbatim}
@EnsuresCalledMethods(expr="#1", methods="close")
public void closeSocket(Socket sock) throws IOException {
    sock.close();
}
\end{verbatim}

After any call to this method, its first parameter is guaranteed to have had \<close()> called on it
(if the method returns normally). The \<@EnsuresCalledMethods> annotation in the code above expresses
this fact. You may need to write such annotations in your own code.

A common source of false positive errors from the Resource Leak Checker relates to these kind of helper
methods. Suppose that the body of \<closeSocket> above had an additional call to some other method
\<m()> after the call to \<sock.close()>. If \<m()> might have side-effects (i.e. it is not annotated
as \<@SideEffectFree>), then the Called Methods Checker will be unable to verify that \<close()> is definitely
called on \<sock> before \<closeSocket()> returns, and will issue an error. There are two possible fixes:
\begin{itemize}
\item add an \<@SideEffectFree> annotation to \<m()>, if it is in fact side-effect free; or
\item re-order the calls to \<sock.close()> and \<m()> so that the call to \<sock.close()> appears
last in \<closeSocket()>.
\end{itemize}

\sectionAndLabel{Ownership transfer}{resource-leak-ownership}

Consider the following code that safely closes a \<Socket>:

\begin{verbatim}
  void example(String myHost, int myPort) {
    Socket s = new Socket(myHost, myPort);
    closeSocket(s);
  }
  void closeSocket(@Owning @MustCall("close") Socket t) {
    t.close();
  }
\end{verbatim}

The \<closeSocket()> routine takes ownership of the socket---that is,
it takes responsibility for closing it. Without the \<@Owning>
annotation on \<t>, the Resource Leak Checker would issue a false positive on this
code, because it would warn when \<s>
goes out of scope in \<example()>.

\<@Owning> and \<@NotOwning> always \emph{transfer} must-call obligations: must-call
obligations are conserved (i.e. neither created nor destroyed) by any ownership annotations
that you write, by construction. Writing \<@Owning> or \<@NotOwning> can never make the checker
unsound (i.e. a real warning can never be hidden by them),
but writing (or failing to write) these annotations can introduce false positives (i.e. extra warnings).

Constructor returns are always \<@Owning>.
The Resource Leak Checker's default for unannotated method returns is \<@Owning>,
and for unannotated parameters and fields is \<@NotOwning>. This treatment of parameter and
return types ensures sound handling of unannotated third-party libraries: any
object returned from such a library will be tracked by default, and the checker
never assumes that passing an object to an unannotated library will satisfy its obligations.
This feature can be disabled by passing the \<-AnoLightweightOwnership> command-line parameter to the Resource
Leak Checker. In this mode, the defaults described in this paragraph are always used, and explicit \<@Owning>
and \<@NotOwning> annotations are ignored.

\subsectionAndLabel{Owning fields}{resource-leak-owning-fields}

By default, fields are treated as non-owning.

Additional class-level checking is required for \<@Owning>
fields, as the code
satisfying their must-call obligations nearly always spans multiple
procedures.

For final, non-static owning fields,
which cannot be overwritten after initialization of the enclosing
object, the Resource Leak Checker enforces the ``resource acquisition is
initialization (RAII)'' programming idiom: a distinguished
``destructor''-like method \<d()> must ensure the field's must-call obligation is
satisfied, and the enclosing class must have a \<@MustCall("d")> obligation to
ensure the destructor is called.

Non-final, non-static owning fields usually require one or more \<@CreatesObligation> annotations
when they might be re-assigned. See Section~\ref{resource-leak-non-final-fields} for
more details on how to annotate a non-final, non-static owning field.

The Resource Leak Checker treats all static fields as non-owning, meaning that no assignment to one
can satisfy a must-call obligation.

\sectionAndLabel{Resource aliasing}{resource-leak-resource-alias}

\emph{Resource alias} sets are sets of pointers that
definitely correspond to the same underlying system resource.
Calling a must-call method on one element of a resource-alias set
is equivalent to calling that method on all other members of the set.

Programmers most often encounter resource alaising when using \emph{wrapper types}.
For example, the Java \<BufferedOutputStream> wrapper adds buffering to some other delegate \<OutputStream>.
The wrapper's \<close()> method invokes \<close()> on the delegate---so calling \<close()> on either
will have the same effect (i.e., close the underlying resource).

Resource aliasing relationships are expressed in source code via pairs of \<@MustCallAlias> annotations:
one on a parameter of a method or constructor, and another on its return type.
For example, one constructor of \<BufferedOutputStream> is:
\begin{verbatim}
@MustCallAlias BufferedOutputStream(@MustCallAlias OutputStream arg0);
\end{verbatim}
The Resource Leak Checker uses these annotations at call-sites to treat the relevant variables as if
calling the must-call methods on one also called them on the other.
(Note that these \<@MustCallAlias> annotations already appear on
\<BufferedOutputStream> in the annotated JDK, so you don't need to write
them yourself.)

A pair of \<@MustCallAlias> annotations on a method or constructor \<m>'s return type
and its parameter \<p> can be verified if either of the following holds:
\begin{enumerate}
\item \<p> is passed to another method or constructor in a
  \<@MustCallAlias> position, and \<m> returns that method's result,
  or the call is a \<super()> constructor call annotated
  with \<@MustCallAlias>.
\item \<p> is stored in an \<@Owning> field of the enclosing class.
\end{enumerate}

Support for \<@MustCallAlias> can be disabled by passing the \<-AnoResourceAliases> command-line
argument to the checker. In this mode, resource-alias sets are not tracked by the checker,
and \<@MustCallAlias> is treated identically to \<@PolyMustCall>.

\sectionAndLabel{Creating obligations}{resource-leak-creates-obligation}

Every constructor of a class that has must-call obligations
implicitly creates obligations for the newly-created object.
However, non-constructor methods may also create obligations
when re-assigning non-final, owning fields or allocating
new system-level resources.
A post-condition annotation,
\<@CreatesObligation>,
indicates for which expression an obligation is created.

When checking a call to a method annotated as
\<@CreatesObligation(>$expr$\<)>, the Resource Leak Checker
(1) treats the \<@MustCall>
obligation of $expr$ as \emph{satisfied},
and (2) creates a fresh obligation to check.
This is sound: the checker creates a new obligation for calls to
\<@CreatesObligation> methods, and the Must Call Checker (Section~\ref{must-call-checker}) ensures the
\<@MustCall> type for the target will have a \emph{superset} of any methods present
before the call.
There is an exception to this check: if an \<@CreatesObligation>
method is invoked within a method that has an \<@CreatesObligation> annotation
with the same target---imposing the obligation on its caller---then
the new obligation is treated as satisfied immediately (because it is instead imposed
on the callee of the latter).

Support for \<@CreatesObligation> can be disabled by passing the \<-AnoCreatesObligation> command-line
argument to the checker. In this mode, \<@CreatesObligation> annotations on methods are ignored at call-sites,
but re-assigning a non-final, owning field is always an error.

\subsectionAndLabel{Re-assigning to non-final, owning fields}{resource-leak-non-final-fields}

\<@CreatesObligation> allows the Resource Leak Checker to verify uses of non-final fields
that contain a resource, even if they are re-assigned. Consider
the following example:

\begin{verbatim}
  @MustCall("close") // default qualifier for uses of SocketContainer
  class SocketContainer {
    private @Owning Socket sock;
    public SocketContainer() { sock = ...; }
    void close() { sock.close() };
    @CreatesObligation("this")
    void reconnect() {
      if (!sock.isClosed()) {
        sock.close();
      }
      sock = ...;
    }
  }
\end{verbatim}

In the lifetime of a \<SocketContainer> object, \<sock>
might be re-assigned arbitrarily many times: once at each
call to \<reconnect()>. This code is safe, however: \<reconnect()>
ensures that \<sock> is closed before re-assigning it.

The Resource Leak Checker enforces two rules to ensure that
re-assignments to non-final, owning fields like \<sock> in the example
above are sound:
\begin{itemize}
\item any method that re-assigns a non-final, owning field of an object
  must be annotated with an \<@CreatesObligation> annotation
  that targets that object.
\item when a non-final, owning field $f$ is re-assigned at statement $s$,
  its inferred \<@MustCall> obligation must be contained in its \<@CalledMethods>
  type at the program point before $s$.
\end{itemize}
\noindent
The first rule ensures that \<close()> is called after the last call
to \<reconnect()>, and the second rule ensures that \<reconnect()>
safely closes \<sock> before re-assigning it. Because calling
an \<@CreatesObligation> method like \<reconnect()> also resets called-methods
inference, calls to \<close> before the last call to \<reconnect()>
are disregarded.

% TODO: should this section also include text about unconnected sockets, or is what's here sufficient?

% LocalWords:  de subchecker OutputStream MustCall MustCallUnknown
% LocalWords:  PolyMustCall InheritableMustCall MultiRandSelector
% LocalWords:  Partitioner
