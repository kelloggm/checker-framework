\htmlhr
\chapterAndLabel{Must Call Checker}{mustcall-checker}

The MustCall Checker tracks the methods that an object should call before it is deallocated
and produces a conservative overapproximation of the set of methods that might
actually need to be called on an object.
It is intended to be run as a subchecker of another checker: on its own, it does not
enforce any rules other than subtyping.

For example, an object whose type is \<java.io.OutputStream> might
have an obligation to call the \<close()> method, to release an underlying file resource. Or,
such an \<OutputStream> might not have such an obligation, if the underlying resource is
a byte array. Either of these obligations can be represented by the static type
\<@MustCall(\{"close"\}) OutputStream>, which can be read as ``an OutputStream that might need
to call close before it is deallocated''.

\sectionAndLabel{MustCall annotations}{must-call-annotations}

The MustCall Checker supports these qualifiers and declaration annotations:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{MustCall}{String[] value}]
  indicates that the qualifier's arguments are the methods that the annotated type
  should call. The type \<@MustCall(\{"a"\}) Object obj> means
  that before \<obj> is deallocated, \<obj.a()> should be called.
  The default type qualifier for an unannotated type is \<@MustCall(\{\})>.

\item[\refqualclass{checker/mustcall/qual}{MustCallUnknown}]
  is used internally by the type system but should never be written by a
  programmer.  It theoretically represents a value with an unknowable or infinite set
  of must-call methods.

\item[\refqualclasswithparams{checker/mustcall/qual}{InheritableMustCall}{String[] value}]
  is an alias of \<@MustCall> that can only be written on a class declaration. It adds an \<@MustCall>
  annotation with the same arguments to
  the class declaration on which it is written, and also to all subclasses, freeing the user of the need
  to write the \<@MustCall> annotation on every subclass.

\item[\refqualclass{checker/mustcall/qual}{PolyMustCall}]
  is the polymorphic annotation for the MustCall type system
  (Section~\ref{method-qualifier-polymorphism}).

\item[\refqualclass{checker/mustcall/qual}{MustCallAlias}]
  is a special polymorphic annotation that indicates a resource-aliasing relationship between
  the annotated elements. Internally, the MustCall Checker treats it identically to \<@PolyMustCall>.

\item[\refqualclasswithparams{checker/mustcall/qual}{CreatesObligation}{String value}]
  is a declaration annotation that can be written on a method or constructor. It takes a single Java expression as an
  argument, referred to as its ``target''. The annotated method
  ``resets'' the must-call obligations of its target to the least upper bound of their current value and the default
  must-call obligations for its declared type. This annotation is repeatable, if the copies have different targets.

\item[\refqualclass{checker/mustcall/qual}{Owning}]
  is a declaration annotation that can be written on a method parameter, method return type, or
  field declaration. It indicates that the annotated element is the ``owning'' pointer to any resource,
  and the MustCall Checker may never forget information about its obligations.

\item[\refqualclass{checker/mustcall/qual}{NotOwning}]
  is a declaration annotation that can be written on a method parameter, method return type, or
  field declaration. It indicates that the annotated element is \emph{not} the ``owning'' pointer to any resource,
  and the MustCall Checker may forget information about its obligations temporarily.

\end{description}

A subset of the infinite lattice of the type hierarchy is shown in Figure~\ref{fig-must-call-hierarchy}.

\begin{figure}
\includeimage{mustcall}{5cm}
\caption{The subtyping relationship of (some of) the MustCall Checker's qualifiers.
Qualifiers in gray are used internally by the type system but should
never be written by a programmer.}
\label{fig-must-call-hierarchy}
\end{figure}

\<@MustCall(\{"a"\}) Object> can only
contain an object that needs to call \<a> or one that needs to call nothing --- an
object that needs to call \<b> (or both \<a> and \<b>) is not permitted.
Any expression of type \<@MustCall(\{\}) Object> also has type
\<@MustCall(\{"a"\}) Object>.
\<@MustCall(\{"a", "b"\}) Object> represents all objects that need to
call \<a>, \<b>, both, or neither; it cannot not represent an object that needs
to call some other method.

The default type in unannotated code is \<@MustCall(\{\})>.
A completely unannotated program will always type-check without warnings.
For the MustCall Checker to be useful, the programmer should supply at least one non-empty
\<@MustCall> annotation, either in source code or in a stub file.

Note that it is always safe to write \<@Owning> and \<@NotOwning>
annotations anywhere in your code (they are only hints to the checker),
though writing annotations that differ from the program's design may lead
the Must Call checker to issue false positive warnings.


\sectionAndLabel{Example use}{must-call-example}

If a user annotates a class declaration with a \<@MustCall(...)> annotation, any use of the class's
type has that \<@MustCall> annotation by default. For example, given the following class annotation:
\begin{Verbatim}
    package java.net;

    import org.checkerframework.checker.mustcall.qual.MustCall;

    @MustCall({"close"}) class Socket { }
\end{Verbatim}
any use of \<Socket> defaults to \<@MustCall(\{"close"\}) Socket>.

\sectionAndLabel{Implementation details and caveats}{must-call-impl}

This type system should not be used to track a must-call obligation for a \<String>, because it treats all
String concatenations as having the type \<@MustCall(\{\})>.
Normally it is the case that a newly-constructed String (whether created via new String or a string literal
or concatenation) has no must-call obligation, just like any other object whose type declaration isn't annotated with a
non-empty \<@MustCall> type. \<java.lang.String> is an exception: even if the declaration of \<java.lang.String> were
annotated with a non-empty \<@MustCall> annotation, the result of a string concatenation would still be \<@MustCall(\{\})>.

This special-casing is to avoid cases where
an object with a must-call obligation is implicitly converted to a \<String>, creating a must-call obligation
that could never be fulfilled (this is not unsound, but it does reduce precision). For example, suppose that
all \<Socket> objects are \<@MustCall(\{"close"\})>. Without special-casing string concatenations, the type of
\<str> in the following code would be \<@MustCall(\{"close"\})>, even though \<str>'s dynamic type is \<String>, not
\<Socket>:
\begin{Verbatim}
    Socket sock = ...;
    String str = "this is the result of my socket's toString() function, which is invoked implicitly: " + sock;
\end{Verbatim}

\sectionAndLabel{Type parameters with implicit vs explicit bounds sometimes cause (fixable) false positives}{must-call-type-params}

The defaulting rules for \<@MustCall> sometimes produce unexpected errors in code
that uses type parameters with implicit upper bounds (i.e. without an \<extends> clause).
The errors can be fixed by adding an explicit bound. For example, consider the following
example of a class with a type parameter and a field of an interface type that uses that
type parameter (from \href{https://github.com/plume-lib/plume-util}{plume-lib/plume-util}):
\begin{Verbatim}
    class MultiRandSelector<T> {
        private Partition<T, T> eq;
    }

    interface Partition<ELEMENT extends @Nullable Object, CLASS extends @Nullable Object> {}
\end{Verbatim}

Running the Must Call Checker on this code produces two unexpected errors, at each use
of \<T> in \<MultiRandSelector>:

\begin{Verbatim}
must-call-checker/tests/mustcall/PlumeUtilRequiredAnnotations.java:19: error: [type.argument.type.incompatible] incompatible type argument for type parameter ELEMENT of Partitioner.
        private Partitioner<T, T> eq;
                            ^
  found   : T extends @MustCallUnknown Object
  required: @MustCall Object
must-call-checker/tests/mustcall/PlumeUtilRequiredAnnotations.java:19: error: [type.argument.type.incompatible] incompatible type argument for type parameter CLASS of Partitioner.
        private Partitioner<T, T> eq;
                               ^
  found   : T extends @MustCallUnknown Object
  required: @MustCall Object
\end{Verbatim}

The important mismatch here is that \<Partitioner> has explicit bounds, but \<MultiRandSelector>
does not. You could eliminate this false positive by either:
\begin{itemize}
\item adding an explicit bound to \<MultiRandSelector>: i.e. changing its declaration to \<class MultiRandSelector<T extends Object>>, or
\item removing the explicit bound from \<Partition>: i.e. changing its declaration to \<interface Partition<ELEMENT, CLASS>>.
\end{itemize}

These two changes are semantically equivalent, but you might prefer one over the other (in this case, for example,
we preferred the former, since changing to the latter would remove the explicit \<@Nullable> annotations on
\<ELEMENT> and \<CLASS>).
