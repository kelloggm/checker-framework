\htmlhr
\chapterAndLabel{Must Call Checker}{mustcall-checker}

The Must Call Checker conservatively over-approximates
the set of methods that an object should call before it is de-allocated.
It is intended to be run as a subchecker of another checker: on its own, it does not
enforce any rules other than subtyping.

For example, consider an object whose type is \<java.io.OutputStream>.
This \<OutputStream> might have an obligation to call the \<close()> method, to release an
underlying file resource. The type of this \<OutputStream> is \<@MustCall(\{"close"\})>.
 Or, the \<OutputStream> might not have such an obligation, if the
underlying resource is a byte array. The type of this \<OutputStream> is \<@MustCall(\{\})>.
The Must Call Checker over-approximates the methods that an arbitrary
\<OutputStream> should call by assigning it the type \<@MustCall(\{"close"\}) OutputStream>, which can be read
as "an OutputStream that might need to call close() (but no other methods) before it is de-allocated".

\sectionAndLabel{Must Call annotations}{must-call-annotations}

The Must Call Checker supports these type qualifiers, whose subtyping relationships
are shown in Figure~\ref{fig-must-call-hierarchy}:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{MustCall}{String[] value}]
  gives a superset of the methods that the annotated program element
  must call before it is de-allocated.
  The default type qualifier for an unannotated type is \<@MustCall(\{\})>.

\item[\refqualclass{checker/mustcall/qual}{MustCallUnknown}]
  represents a value with an unknowable or infinite set of must-call methods.
  It is used internally by the type system but should never be written by a
  programmer.

\item[\refqualclasswithparams{checker/mustcall/qual}{InheritableMustCall}{String[] value}]
  is an alias of \<@MustCall> that can only be written on a class declaration.
  It applies both to the class declaration on which it is written and also to all subclasses.
  This frees the user of the need to write the \<@MustCall> annotation on every subclass.

\item[\refqualclass{checker/mustcall/qual}{PolyMustCall}]
  is the polymorphic annotation for the Must Call type system.
  For a description of polymorphic qualifiers, see
  Section~\ref{method-qualifier-polymorphism}.

\end{description}

\begin{figure}
\includeimage{mustcall}{5cm}
\caption{Subtyping relationships between examples of type qualifiers from the Must Call Checker's type
hierarchy (note that this is only part of the full hierarchy, which contains one \<@MustCall> annotation
for every combination of methods).
Qualifiers in gray are used internally by the type system but should
never be written by a programmer.}
\label{fig-must-call-hierarchy}
\end{figure}

\<@MustCall(\{"foo"\}) Object> can only
contain an object that needs to call \<foo> or one that needs to call nothing --- an
object that needs to call \<bar> (or both \<foo> and \<bar>) is not permitted.
Any expression of type \<@MustCall(\{\}) Object> also has type
\<@MustCall(\{"foo"\}) Object>.
\<@MustCall(\{"foo", "bar"\}) Object> represents all objects that need to
call \<foo>, \<bar>, both, or neither; it cannot not represent an object that needs
to call some other method.

The default type in unannotated code is \<@MustCall(\{\})>.
A completely unannotated program will always type-check without warnings.
For the Must Call Checker to be useful, the programmer should supply at least one non-empty
\<@MustCall> annotation, either in source code or in a stub file.

\sectionAndLabel{Writing \<@MustCall> on a class}{must-call-on-class}

As explained in Section~\ref{upper-bound-for-use}, if a user writes a type
annotation on a class declaration, any use of the class's type has that
annotation by default.

For example, given the following class annotation:
\begin{Verbatim}
    package java.net;

    import org.checkerframework.checker.mustcall.qual.MustCall;

    @MustCall({"close"}) class Socket { }
\end{Verbatim}
any use of \<Socket> defaults to \<@MustCall(\{"close"\}) Socket>.

%% \sectionAndLabel{Lightweight ownership annotations}{must-call-ownership-annos}

%% TODO: this explanation feels...lacking to me. It doesn't make that much sense IMO
%% without explaining the must-call consistency checker's usage of Owning/NotOwning.
%% It's therefore been commented out here. Some version of this needs to appear, either
%% here or in the documentation of the consistency checker, when that is merged. For now,
%% this manual page doesn't list @Owning or @NotOwning at all, because they can't be explained
%% without context - so we've decided to treat them as if they don't exist, for now.

%% In many programs, aliasing creates two or more program elements that represent the same
%% underlying object on which some methods might need to be called (i.e. whose type has a non-empty
%% \<@MustCall> qualifier). For example, an \<OutputStream> might be stored in both
%% a local variable and a field. Typically, the Must Call Checker will over-approximate both
%% the local variable and the field (and any other pointers to the object) as \<@MustCall(\{"close"\})>:
%% that is, because all \<OutputStream> objects might need to be closed, each pointer to an
%% \<OutputStream> might need to be closed, too. In practice, however, some of these pointers can be
%% ignored: they are \emph{non-owning}. In the example of an \<OutputStream> that is stored in both
%% a local variable and a field, for instance, it may be the case that the field is non-owning (such
%% as a cache) and the local is owning; or, it might be the case that the field is owning (an open connection,
%% for example, that will be closed later), and the local is non-owning.

%% The Must Call Checker supplies two annotations to support this concept: \<@Owning> and \<@NotOwning>.
%% The Must Call Checker's support for these annotations is limited: method parameters annotated as
%% \<@NotOwning> are treated as bottom (i.e. \<@MustCall(\{\})>) within the method bodies in which they
%% appear. A client analysis of the Must Call Checker can use these annotations as a guide for which
%% pointer to a given object is intended by the programmer as the pointer through which the must-call obligations
%% of the object are satisfied, but these annotations are only hints.

%% This feature can be disabled by passing the \<-AnoLightweightOwnership> command-line parameter to the Must
%% Call Checker.


\sectionAndLabel{Strings cannot have must-call obligations}{must-call-impl}

This type system should not be used to track a must-call obligation for a \<String>, because it treats all
String concatenations as having the type \<@MustCall(\{\})>.  (It does so
even if you change the annotated JDK or a stub file to add a
\<@MustCall(...)>\@ annotation to the declaration of \<String>.)

This special-casing is because an object is sometimes implicitly converted
to a \<String>, which inherits the object's annotations.
Consider the following example:
\begin{Verbatim}
    @MustCall("close") Socket sock = ...;
    String str = "here is sock.toString(): " + sock;
\end{Verbatim}
\noindent
Without special-casing string concatenations, the type of
\<str> would be \<@MustCall(\{"close"\})>.  This is not unsound, but it
does lead to imprecision since the string does not need to be closed.


\sectionAndLabel{Type parameters with implicit vs explicit bounds sometimes cause (fixable) false positives}{must-call-type-params}

The defaulting rules for \<@MustCall> sometimes produce unexpected checker
warnings in code that uses type parameters with implicit upper bounds
(i.e., without an \<extends> clause).  You can prevent the checker from
issuing the warning by adding an explicit bound. For example, consider the following
example (from
\href{https://github.com/plume-lib/plume-util}{plume-lib/plume-util}) of a
class with a type parameter and a field of an interface type that uses that
type parameter:
\begin{Verbatim}
    class MultiRandSelector<T> {
        private Partition<T, T> eq;
    }

    interface Partition<ELEMENT extends @Nullable Object, CLASS extends @Nullable Object> {}
\end{Verbatim}

Running the Must Call Checker on this code produces two errors, at each use
of \<T> in \<MultiRandSelector>:

\begin{smaller}
\begin{Verbatim}
error: [type.argument.type.incompatible] incompatible type argument for type parameter ELEMENT of Partitioner.
        private Partitioner<T, T> eq;
                            ^
  found   : T extends @MustCallUnknown Object
  required: @MustCall Object
error: [type.argument.type.incompatible] incompatible type argument for type parameter CLASS of Partitioner.
        private Partitioner<T, T> eq;
                               ^
  found   : T extends @MustCallUnknown Object
  required: @MustCall Object
\end{Verbatim}
\end{smaller}

The important mismatch here is that \<Partitioner> has explicit bounds, but \<MultiRandSelector>
does not. You could eliminate this false positive by either:
\begin{itemize}
\item adding an explicit bound to \<MultiRandSelector>, changing its declaration to \<class MultiRandSelector<T extends Object>>, or
\item removing the explicit bound from \<Partition>, changing its declaration to \<interface Partition<ELEMENT, CLASS>>.
\end{itemize}

These two changes are semantically equivalent.  In this case, we preferred
the former, since the latter would remove the explicit \<@Nullable>
annotations on \<ELEMENT> and \<CLASS>).
