\htmlhr
\chapterAndLabel{Must Call Checker}{mustcall-checker}

The Must Call Checker conservatively over-approximates
the set of methods that an object should call before it is de-allocated.
It is intended to be run as a subchecker of another checker: on its own, it does not
enforce any rules other than subtyping.

For example, an object whose type is \<java.io.OutputStream> might
have an obligation to call the \<close()> method, to release an underlying file resource. Or,
such an \<OutputStream> might not have such an obligation, if the underlying resource is
a byte array. The Must Call Checker therefore over-approximates the methods that such an
\<OutputStream> should call by producing the set containing \<close()>.

\sectionAndLabel{Must Call annotations}{must-call-annotations}

The Must Call Checker supports these type qualifiers, whose subtyping relationships
are shown in Figure~\ref{fig-must-call-hierarchy}:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{MustCall}{String[] value}]
  indicates that the qualifier's arguments are a superset of the methods that the annotated program element
  must call before it is de-allocated.
  The type \<@MustCall(\{"close"\}) OutputStream>, for example, can be read as ``an OutputStream that might need
  to call close before it is de-allocated.''
  The default type qualifier for an unannotated type is \<@MustCall(\{\})>.

\item[\refqualclass{checker/mustcall/qual}{MustCallUnknown}]
  is used internally by the type system but should never be written by a
  programmer.  It theoretically represents a value with an unknowable or infinite set
  of must-call methods.

\item[\refqualclasswithparams{checker/mustcall/qual}{InheritableMustCall}{String[] value}]
  is an alias of \<@MustCall> that can only be written on a class declaration. It adds an \<@MustCall>
  annotation with the same arguments to
  the class declaration on which it is written, and also to all subclasses, freeing the user of the need
  to write the \<@MustCall> annotation on every subclass.

\item[\refqualclass{checker/mustcall/qual}{PolyMustCall}]
  is the polymorphic annotation for the Must Call type system.

\item[\refqualclass{checker/mustcall/qual}{MustCallAlias}]
  is a special polymorphic annotation that indicates a resource-aliasing relationship between
  the annotated elements. Internally, the Must Call Checker treats it identically to \<@PolyMustCall>.

%% TODO: after the Must Call Consistency checker is merged, add an example of how to use @MustCallAlias

\end{description}

The Must Call Checker also supports these declaration annotations:

\begin{description}

\item[\refqualclasswithparams{checker/mustcall/qual}{CreatesObligation}{String value}]
  is a declaration annotation that can be written on a method or constructor. It takes a single Java expression as an
  argument, referred to as its ``target''. Intuitively, this annotation means that the annotated method
  ``resets'' the must-call obligations of its target to the least upper bound of their current value and the default
  must-call obligations for its declared type. This annotation is repeatable, if the copies have different targets.

%% TODO: after the Must Call Consistency checker is merged, add an example of how to use @CreatesObligation

\item[\refqualclass{checker/mustcall/qual}{Owning}]
  is a declaration annotation that can be written on a method parameter, method return type, or
  field declaration. It indicates that the annotated element is the ``owning'' pointer to any resource.
  See Section~\ref{must-call-ownership-annos} for more details on ownership.

\item[\refqualclass{checker/mustcall/qual}{NotOwning}]
  is a declaration annotation that can be written on a method parameter, method return type, or
  field declaration. It indicates that the annotated element is \emph{not} the ``owning'' pointer to any resource,
  regardless of its type in the Must Call Checker's hierarchy.
  See Section~\ref{must-call-ownership-annos} for more details on ownership.

%% TODO: after the Must Call Consistency checker is merged, add an examples of how to use @Owning and @NotOwning

\end{description}

\begin{figure}
\includeimage{mustcall}{5cm}
\caption{Subtyping relationships between examples of type qualifiers from the Must Call Checker's type
hierarchy, for an object with only two methods (\<a> and \<b>).
The lattice for a given type contains one \<@MustCall> annotation for each element of the powerset
of methods that can be called on that type.
Qualifiers in gray are used internally by the type system but should
never be written by a programmer.}
\label{fig-must-call-hierarchy}
\end{figure}

Note that \<@MustCall(\{"a", "b"\}) Object> represents more possible values than
\<@MustCall(\{"a"\}) Object> does, because \<@MustCall(\{"a"\}) Object> can only
contain an object that needs to call \<a> or one that needs to call nothing --- an
object that needs to call \<b> (or both \<a> and \<b>) is not permitted.
\<@MustCall(\{"a", "b"\}) Object> represents all objects that need to
call \<a>, \<b>, both, or neither; it cannot not represent an object that needs
to call some other method.

The default type in unannotated code is \<@MustCall(\{\})>.
A completely unannotated program will always type-check without warnings.
For the Must Call Checker to be useful, the programmer should supply at least one non-empty
\<@MustCall> annotation, either in source code or in a stub file.

Note that it is always safe to write \<@Owning> and \<@NotOwning> annotations anywhere in your
code (they are only hints to the checker), though doing so may reduce precision.

\sectionAndLabel{Example use}{must-call-example}

If a user annotates a class declaration with a \<@MustCall(...)> annotation, any use of the class's
type has that \<@MustCall> annotation by default. For example, given the following class annotation:
\begin{Verbatim}
    package java.net;

    import org.checkerframework.checker.mustcall.qual.MustCall;

    @MustCall({"close"}) class Socket { }
\end{Verbatim}
any use of \<Socket> defaults to \<@MustCall(\{"close"\}) Socket>.

\sectionAndLabel{Lightweight ownership annotations}{must-call-ownership-annos}

%% TODO: this explanation feels...lacking to me. It doesn't make that much sense IMO
%% without explaining the must-call consistency checker's usage of Owning/NotOwning.

In many programs, aliasing creates two or more program elements that represent the same
underlying object on which some methods might need to be called (i.e. whose type has a non-empty
\<@MustCall> qualifier). For example, an \<OutputStream> might be stored in both
a local variable and a field. Typically, the Must Call Checker will over-approximate both
the local variable and the field (and any other pointers to the object) as \<@MustCall(\{"close"\})>:
that is, because all \<OutputStream> objects might need to be closed, each pointer to an
\<OutputStream> might need to be closed, too. In practice, however, some of these pointers can be
ignored: they are \emph{non-owning}. In the example of an \<OutputStream> that is stored in both
a local variable and a field, for instance, it may be the case that the field is non-owning (such
as a cache) and the local is owning; or, it might be the case that the field is owning (an open connection,
for example, that will be closed later), and the local is non-owning.

The Must Call Checker supplies two annotations to support this concept: \<@Owning> and \<@NotOwning>.
The Must Call Checker's support for these annotations is limited: method parameters annotated as
\<@NotOwning> are treated as bottom (i.e. \<@MustCall(\{\})>) within the method bodies in which they
appear. A client analysis of the Must Call Checker can use these annotations as a guide for which
pointer to a given object is intended by the programmer as the pointer through which the must-call obligations
of the object are satisfied, but these annotations are only hints.

This feature can be disabled by passing the \<-AnoLightweightOwnership> command-line parameter to the Must
Call Checker.

\sectionAndLabel{Strings cannot have must-call obligations}{must-call-impl}

This type system should not be used to track a must-call obligation for a \<String>, because it treats all
String concatenations as having the type \<@MustCall(\{\})>.
Normally it is the case that a newly-constructed String (whether created via new String or a string literal
or concatenation) has no must-call obligation, just like any other object whose type declaration isn't annotated with a
non-empty \<@MustCall> type. \<java.lang.String> is an exception: even if the declaration of \<java.lang.String> were
annotated with a non-empty \<@MustCall> annotation, the result of a string concatenation would still be \<@MustCall(\{\})>.

This special-casing is to avoid cases where
an object with a must-call obligation is implicitly converted to a \<String>, creating a must-call obligation
that could never be fulfilled (this is not unsound, but it does reduce precision). For example, suppose that
all \<Socket> objects are \<@MustCall(\{"close"\})>. Without special-casing string concatenations, the type of
\<str> in the following code would be \<@MustCall(\{"close"\})>, even though \<str>'s dynamic type is \<String>, not
\<Socket>:
\begin{Verbatim}
    Socket sock = ...;
    String str = "this is the result of my socket's toString() function, which is invoked implicitly: " + sock;
\end{Verbatim}

\sectionAndLabel{Type parameters with implicit vs explicit bounds sometimes cause (fixable) false positives}{must-call-type-params}

The defaulting rules for \<@MustCall> sometimes produce unexpected errors in code
that uses type parameters with implicit upper bounds (i.e. without an \<extends> clause).
The errors can be fixed by adding an explicit bound, as described in Section~\ref{upper-bound-for-use}.
For example, consider the following
example of a class with a type parameter and a field of an interface type that uses that
type parameter (from \href{https://github.com/plume-lib/plume-util}{plume-lib/plume-util}):
\begin{Verbatim}
    class MultiRandSelector<T> {
        private Partition<T, T> eq;
    }

    interface Partition<ELEMENT extends @Nullable Object, CLASS extends @Nullable Object> {}
\end{Verbatim}

Running the Must Call Checker on this code produces two unexpected errors, at each use
of \<T> in \<MultiRandSelector>:

\begin{Verbatim}
must-call-checker/tests/mustcall/PlumeUtilRequiredAnnotations.java:19: error: [type.argument.type.incompatible] incompatible type argument for type parameter ELEMENT of Partitioner.
        private Partitioner<T, T> eq;
                            ^
  found   : T extends @MustCallUnknown Object
  required: @MustCall Object
must-call-checker/tests/mustcall/PlumeUtilRequiredAnnotations.java:19: error: [type.argument.type.incompatible] incompatible type argument for type parameter CLASS of Partitioner.
        private Partitioner<T, T> eq;
                               ^
  found   : T extends @MustCallUnknown Object
  required: @MustCall Object
\end{Verbatim}

The important mismatch here is that \<Partitioner> has explicit bounds, but \<MultiRandSelector>
does not. You could eliminate this false positive by either:
\begin{itemize}
\item adding an explicit bound to \<MultiRandSelector>: i.e. changing its declaration to \<class MultiRandSelector<T extends Object>>, or
\item removing the explicit bound from \<Partition>: i.e. changing its declaration to \<interface Partition<ELEMENT, CLASS>>.
\end{itemize}

These two changes are semantically equivalent, but you might prefer one over the other (in this case, for example,
we preferred the former, since changing to the latter would remove the explicit \<@Nullable> annotations on
\<ELEMENT> and \<CLASS>).
